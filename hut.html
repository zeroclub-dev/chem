<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Professor Smith's Laboratory</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.6.1/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r132/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: #111;
            color: #ffffff;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #0a3955;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 1s ease;
        }

        .loading.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loader {
            width: 80px;
            height: 80px;
            border: 5px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #ffffff;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }
            100% {
                transform: rotate(360deg);
            }
        }

        .title-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            transition: opacity 1s ease;
        }

        .title-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .title-content {
            text-align: center;
            padding: 2rem;
            background: rgba(10, 57, 85, 0.8);
            border-radius: 15px;
            max-width: 600px;
        }

        .title-content h1 {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            color: #ffffff;
        }

        .title-content p {
            font-size: 1.2rem;
            margin-bottom: 2rem;
            line-height: 1.6;
        }

        .start-button {
            padding: 0.8rem 2rem;
            font-size: 1.2rem;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .start-button:hover {
            background: #45a049;
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .interaction-guide {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 20px;
            border-radius: 30px;
            font-size: 1rem;
            color: white;
            z-index: 10;
        }

        .tooltip {
            position: absolute;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 14px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 100;
        }

        .back-button {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 0.5rem 1rem;
            font-size: 1rem;
            background: #555;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 10;
        }

        .back-button:hover {
            background: #777;
        }

        .dialog-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 200;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .dialog-container.active {
            opacity: 1;
            pointer-events: auto;
        }

        .dialog {
            background: #f9f9f9;
            color: #333;
            padding: 2rem;
            border-radius: 10px;
            max-width: 600px;
            text-align: center;
        }

        .dialog h2 {
            font-size: 1.8rem;
            margin-bottom: 1rem;
            color: #0a3955;
        }

        .dialog p {
            font-size: 1.1rem;
            margin-bottom: 1.5rem;
            line-height: 1.6;
        }

        .dialog-buttons {
            display: flex;
            justify-content: center;
            gap: 1rem;
        }

        .dialog-button {
            padding: 0.7rem 1.5rem;
            font-size: 1rem;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .continue-button {
            background: #4CAF50;
            color: white;
        }

        .continue-button:hover {
            background: #45a049;
        }

        .cancel-button {
            background: #f44336;
            color: white;
        }

        .cancel-button:hover {
            background: #d32f2f;
        }

        .audio-controls {
            position: absolute;
            bottom: 60px;
            right: 20px;
            display: flex;
            align-items: center;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 30px;
            z-index: 10;
        }

        .audio-controls button {
            background: none;
            border: none;
            color: white;
            font-size: 1.2rem;
            cursor: pointer;
            margin: 0 5px;
            padding: 5px;
        }

        .audio-controls button:hover {
            color: #4CAF50;
        }

        .volume-slider {
            width: 80px;
            margin: 0 10px;
        }
    </style>
</head>
<body>
    <div class="loading">
        <div class="loader"></div>
    </div>

    <div class="title-screen">
        <div class="title-content">
            <h1>Welcome to Professor Smith's Laboratory</h1>
            <p>You've found your way to Professor Smith's research hut! Inside, you'll discover various interactive lab equipment that will teach you about water surface tension. Click on the lab equipment to explore each concept.</p>
            <button class="start-button">Enter the Laboratory</button>
        </div>
    </div>

    <div id="canvas-container"></div>

    <button class="back-button">‚Üê Return to Path</button>

    <div class="interaction-guide">
        Click and drag to look around ‚Ä¢ WASD to move ‚Ä¢ Click on lab equipment to interact
    </div>

    <div class="audio-controls">
        <button id="mute-button">üîä</button>
        <input type="range" min="0" max="100" value="70" class="volume-slider" id="volume-slider">
    </div>

    <div class="tooltip"></div>

    <div class="dialog-container">
        <div class="dialog">
            <h2>Experiment Selection</h2>
            <p>Would you like to view this presentation about water surface tension?</p>
            <div class="dialog-buttons">
                <button class="dialog-button continue-button">Continue to Presentation</button>
                <button class="dialog-button cancel-button">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // Audio setup with Howler.js
        let backgroundMusic;
        
        // Initialize audio
        function initAudio() {
            // Using a placeholder URL - you would replace this with your actual music file
            backgroundMusic = new Howl({
                src: ['mp3/nokia.mp3'],
                loop: true,
                volume: 0.7,
                autoplay: false
            });
            
            // Set up audio controls
            const muteButton = document.getElementById('mute-button');
            const volumeSlider = document.getElementById('volume-slider');
            
            muteButton.addEventListener('click', function() {
                if (backgroundMusic.playing()) {
                    backgroundMusic.pause();
                    muteButton.textContent = 'üîá';
                } else {
                    backgroundMusic.play();
                    muteButton.textContent = 'üîä';
                }
            });
            
            volumeSlider.addEventListener('input', function() {
                const volumeValue = volumeSlider.value / 100;
                backgroundMusic.volume(volumeValue);
                
                // Update the mute button icon based on volume
                if (volumeValue === 0) {
                    muteButton.textContent = 'üîá';
                } else {
                    muteButton.textContent = 'üîä';
                }
            });
        }

        // Wait for everything to load
        window.addEventListener('load', () => {
            // Initialize audio
            initAudio();
            
            setTimeout(() => {
                document.querySelector('.loading').classList.add('hidden');
            }, 1500);
        });
    
        // Title screen interaction
        const titleScreen = document.querySelector('.title-screen');
        const startButton = document.querySelector('.start-button');
    
        startButton.addEventListener('click', () => {
            titleScreen.classList.add('hidden');
            
            // Start playing background music when the user enters the lab
            if (backgroundMusic) {
                backgroundMusic.play();
            }
        });
    
        // Back button functionality
        const backButton = document.querySelector('.back-button');
        backButton.addEventListener('click', () => {
            // Go back to the main scene
            window.location.href = "index.html";
        });
    
        // Dialog setup
        const dialogContainer = document.querySelector('.dialog-container');
        const continueButton = document.querySelector('.continue-button');
        const cancelButton = document.querySelector('.cancel-button');
        let currentSlideURL = '';
    
        // Dialog functionality
        function showDialog(slideURL, title) {
            document.querySelector('.dialog h2').textContent = title;
            currentSlideURL = slideURL;
            dialogContainer.classList.add('active');
        }
    
        continueButton.addEventListener('click', () => {
            if (currentSlideURL) {
                window.location.href = currentSlideURL;
            }
            dialogContainer.classList.remove('active');
        });
    
        cancelButton.addEventListener('click', () => {
            dialogContainer.classList.remove('active');
        });
    
        // THREE.js setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        document.getElementById('canvas-container').appendChild(renderer.domElement);
    
        // Camera setup
        camera.position.set(0, 1.6, 0); // Eye level height
        
        // Controls variables
        let isMouseDown = false;
        let mouseX = 0;
        let mouseY = 0;
        let targetRotationX = 0;
        let targetRotationY = 0;
        let currentRotationX = 0;
        let currentRotationY = 0;
        
        // Movement variables
        const moveSpeed = 0.1;
        const keys = {
            w: false,
            a: false,
            s: false,
            d: false
        };
    
        // Raycaster for object interaction
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const tooltip = document.querySelector('.tooltip');
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        
        const mainLight = new THREE.PointLight(0xffffff, 1);
        mainLight.position.set(0, 3, 0);
        mainLight.castShadow = true;
        scene.add(mainLight);
        
        // Add some directional lighting for better shadow casting
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
        dirLight.position.set(5, 5, 5);
        dirLight.castShadow = true;
        scene.add(dirLight);
    
        // Create the hut interior
        function createRoom() {
            const room = new THREE.Group();
            
            // Floor
            const floorGeometry = new THREE.PlaneGeometry(10, 10);
            const floorMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B4513,
                roughness: 0.8,
                metalness: 0.2
            });
            
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            room.add(floor);
            
            // Walls
            const wallMaterial = new THREE.MeshStandardMaterial({
                color: 0xD2B48C,
                roughness: 0.9,
                metalness: 0.1
            });
            
            // Wall textures
            const woodTexture = new THREE.TextureLoader().load('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8z8BQDwAEhQGAhKmMIQAAAABJRU5ErkJggg==');
            
            // Back wall
            const backWallGeometry = new THREE.BoxGeometry(10, 4, 0.2);
            const backWall = new THREE.Mesh(backWallGeometry, wallMaterial);
            backWall.position.set(0, 2, -5);
            backWall.receiveShadow = true;
            room.add(backWall);
            
            // Left wall
            const leftWallGeometry = new THREE.BoxGeometry(0.2, 4, 10);
            const leftWall = new THREE.Mesh(leftWallGeometry, wallMaterial);
            leftWall.position.set(-5, 2, 0);
            leftWall.receiveShadow = true;
            room.add(leftWall);
            
            // Right wall
            const rightWallGeometry = new THREE.BoxGeometry(0.2, 4, 10);
            const rightWall = new THREE.Mesh(rightWallGeometry, wallMaterial);
            rightWall.position.set(5, 2, 0);
            rightWall.receiveShadow = true;
            room.add(rightWall);
            
            // Front wall with door opening
            const frontWallLeftGeometry = new THREE.BoxGeometry(4, 4, 0.2);
            const frontWallLeft = new THREE.Mesh(frontWallLeftGeometry, wallMaterial);
            frontWallLeft.position.set(-3, 2, 5);
            frontWallLeft.receiveShadow = true;
            room.add(frontWallLeft);
            
            const frontWallRightGeometry = new THREE.BoxGeometry(4, 4, 0.2);
            const frontWallRight = new THREE.Mesh(frontWallRightGeometry, wallMaterial);
            frontWallRight.position.set(3, 2, 5);
            frontWallRight.receiveShadow = true;
            room.add(frontWallRight);
            
            // Door frame
            const doorFrameMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B4513,
                roughness: 0.7,
                metalness: 0.3
            });
            
            // Top door frame
            const topFrameGeometry = new THREE.BoxGeometry(2, 0.3, 0.3);
            const topFrame = new THREE.Mesh(topFrameGeometry, doorFrameMaterial);
            topFrame.position.set(0, 3.85, 5);
            room.add(topFrame);
            
            // Left door frame
            const leftFrameGeometry = new THREE.BoxGeometry(0.3, 4, 0.3);
            const leftFrame = new THREE.Mesh(leftFrameGeometry, doorFrameMaterial);
            leftFrame.position.set(-1, 2, 5);
            room.add(leftFrame);
            
            // Right door frame
            const rightFrameGeometry = new THREE.BoxGeometry(0.3, 4, 0.3);
            const rightFrame = new THREE.Mesh(rightFrameGeometry, doorFrameMaterial);
            rightFrame.position.set(1, 2, 5);
            room.add(rightFrame);
            
            // Ceiling
            const ceilingGeometry = new THREE.PlaneGeometry(10, 10);
            const ceilingMaterial = new THREE.MeshStandardMaterial({
                color: 0xA0522D,
                roughness: 0.8,
                metalness: 0.2,
                side: THREE.DoubleSide
            });
            
            const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
            ceiling.rotation.x = Math.PI / 2;
            ceiling.position.y = 4;
            ceiling.receiveShadow = true;
            room.add(ceiling);
            
            // Windows
            const windowMaterial = new THREE.MeshStandardMaterial({
                color: 0xADD8E6,
                roughness: 0.2,
                metalness: 0.8,
                transparent: true,
                opacity: 0.7
            });
            
            // FIXED: Window on back wall - positioned slightly in front of the wall to prevent clipping
            const backWindowGeometry = new THREE.PlaneGeometry(1.5, 1.5);
            const backWindow = new THREE.Mesh(backWindowGeometry, windowMaterial);
            backWindow.position.set(0, 2.5, -4.89); // Moved from -4.9 to -4.89 to be in front of the wall
            room.add(backWindow);
            
            // Window frame
            const windowFrameMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B4513,
                roughness: 0.7,
                metalness: 0.3
            });
            
            // FIXED: Windows on side walls - adjusted rotation and position to prevent clipping
            // Window on left wall
            const leftWindowGeometry = new THREE.PlaneGeometry(1.5, 1.5);
            const leftWindow = new THREE.Mesh(leftWindowGeometry, windowMaterial);
            leftWindow.position.set(-4.89, 2.5, -2); // Moved from -4.9 to -4.89
            leftWindow.rotation.y = Math.PI / 2;
            room.add(leftWindow);
            
            // Window on right wall
            const rightWindowGeometry = new THREE.PlaneGeometry(1.5, 1.5);
            const rightWindow = new THREE.Mesh(rightWindowGeometry, windowMaterial);
            rightWindow.position.set(4.89, 2.5, -2); // Moved from 4.9 to 4.89
            rightWindow.rotation.y = -Math.PI / 2;
            room.add(rightWindow);
            
            // Add the room to the scene
            scene.add(room);
            
            return room;
        }
    
        // Create lab equipment
        function createLabEquipment() {
            const labGroup = new THREE.Group();
            
            // Create a large lab table in the center
            const tableGeometry = new THREE.BoxGeometry(5, 0.1, 2.5);
            const tableMaterial = new THREE.MeshStandardMaterial({
                color: 0x5D4037,
                roughness: 0.7,
                metalness: 0.2
            });
            
            const table = new THREE.Mesh(tableGeometry, tableMaterial);
            table.position.set(0, 0.8, -2);
            table.castShadow = true;
            table.receiveShadow = true;
            labGroup.add(table);
            
            // Table legs
            const tablelegGeometry = new THREE.BoxGeometry(0.1, 0.8, 0.1);
            const tablelegMaterial = new THREE.MeshStandardMaterial({
                color: 0x4E342E,
                roughness: 0.8,
                metalness: 0.1
            });
            
            // Add four legs
            const positions = [
                { x: 2.4, z: -3.2 },
                { x: -2.4, z: -3.2 },
                { x: 2.4, z: -0.8 },
                { x: -2.4, z: -0.8 }
            ];
            
            positions.forEach(pos => {
                const leg = new THREE.Mesh(tablelegGeometry, tablelegMaterial);
                leg.position.set(pos.x, 0.4, pos.z);
                leg.castShadow = true;
                labGroup.add(leg);
            });
        
            
            // 1. Microscope - for Slide 1 about molecular forces and "What is surface tension?"
            const microscopeGroup = new THREE.Group();
            
            // Base
            const baseGeometry = new THREE.BoxGeometry(0.5, 0.1, 0.5);
            const baseMaterial = new THREE.MeshStandardMaterial({
                color: 0x333333,
                roughness: 0.3,
                metalness: 0.8
            });
            
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            microscopeGroup.add(base);
            
            // Arm
            const armGeometry = new THREE.BoxGeometry(0.1, 0.5, 0.1);
            const arm = new THREE.Mesh(armGeometry, baseMaterial);
            arm.position.set(0, 0.3, 0);
            microscopeGroup.add(arm);
            
            // Head
            const headGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.3, 16);
            const headMaterial = new THREE.MeshStandardMaterial({
                color: 0x111111,
                roughness: 0.2,
                metalness: 0.9
            });
            
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.rotation.x = Math.PI / 2;
            head.position.set(0, 0.5, 0.15);
            microscopeGroup.add(head);
            
            // Eyepiece
            const eyepieceGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.2, 16);
            const eyepiece = new THREE.Mesh(eyepieceGeometry, headMaterial);
            eyepiece.rotation.x = Math.PI / 2;
            eyepiece.position.set(0, 0.5, -0.1);
            microscopeGroup.add(eyepiece);
            
            // Add a slide under the microscope
            const slideGeometry = new THREE.BoxGeometry(0.4, 0.01, 0.3);
            const slideMaterial = new THREE.MeshStandardMaterial({
                color: 0xFFFFFF,
                transparent: true,
                opacity: 0.8,
                roughness: 0.1,
                metalness: 0.1
            });
            
            const microscopeSlide = new THREE.Mesh(slideGeometry, slideMaterial);
            microscopeSlide.position.set(0, 0.07, 0);
            microscopeGroup.add(microscopeSlide);
            
            // Add a visual representation of water molecules on the slide
            // Create a cluster of small spheres representing molecules
            const moleculeGroup = new THREE.Group();
            const moleculeGeometry = new THREE.SphereGeometry(0.02, 8, 8);
            const moleculeMaterial = new THREE.MeshStandardMaterial({
                color: 0x1E88E5,
                roughness: 0.3,
                metalness: 0.5
            });
            
            // Create a pattern of molecules to illustrate surface tension
            // Top layer (surface) molecules - more tightly packed
            for (let i = 0; i < 6; i++) {
                for (let j = 0; j < 6; j++) {
                    const molecule = new THREE.Mesh(moleculeGeometry, moleculeMaterial);
                    molecule.position.set(
                        -0.15 + i * 0.06,
                        0.085,
                        -0.1 + j * 0.04
                    );
                    moleculeGroup.add(molecule);
                }
            }
            
            // Lower molecules - less organized
            for (let i = 0; i < 15; i++) {
                const molecule = new THREE.Mesh(moleculeGeometry, moleculeMaterial);
                molecule.position.set(
                    -0.15 + Math.random() * 0.3,
                    0.075 - Math.random() * 0.02,
                    -0.1 + Math.random() * 0.2
                );
                moleculeGroup.add(molecule);
            }
            
            microscopeGroup.add(moleculeGroup);
            
            // Add a small holographic-like projection above showing "Surface Tension"
            const textGeometry = new THREE.PlaneGeometry(0.4, 0.2);
            const textMaterial = new THREE.MeshBasicMaterial({
                color: 0x4FC3F7,
                transparent: true,
                opacity: 0.7,
                side: THREE.DoubleSide
            });
            
            const textPlane = new THREE.Mesh(textGeometry, textMaterial);
            textPlane.position.set(0, 0.9, 0);
            textPlane.rotation.x = -Math.PI / 6;
            microscopeGroup.add(textPlane);
            
            // Position the microscope
            microscopeGroup.position.set(-1.5, 0.85, -2.5);
            microscopeGroup.userData = { 
                isInteractive: true, 
                slideURL: 'slide1.html',
                name: 'What is Surface Tension?', 
                description: 'Learn about molecular forces and how they create surface tension',
                title: 'What is Surface Tension?'
            };
            labGroup.add(microscopeGroup);
            
            // 2. Beaker with colored liquid - for Slide 2 about "Why surface tension happens"
            const beakerGroup = new THREE.Group();
            
            // Beaker cylinder
            const beakerGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.4, 16, 1, true);
            const beakerMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.6,
                roughness: 0.1,
                metalness: 0.3
            });
            
            const beaker = new THREE.Mesh(beakerGeometry, beakerMaterial);
            beakerGroup.add(beaker);
            
            // Base of beaker
            const beakerBaseGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.05, 16);
            const beakerBaseMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.8,
                roughness: 0.1,
                metalness: 0.3
            });
            
            const beakerBase = new THREE.Mesh(beakerBaseGeometry, beakerBaseMaterial);
            beakerBase.position.y = -0.225;
            beakerGroup.add(beakerBase);
            
            // Colored liquid in beaker with curved top surface to show tension
            const liquidGeometry = new THREE.CylinderGeometry(0.18, 0.18, 0.3, 16);
            const liquidMaterial = new THREE.MeshStandardMaterial({
                color: 0x1E88E5, // Blue color
                transparent: true,
                opacity: 0.7,
                roughness: 0.1,
                metalness: 0.1
            });
            
            const liquid = new THREE.Mesh(liquidGeometry, liquidMaterial);
            liquid.position.y = -0.05;
            beakerGroup.add(liquid);
            
            // Add a slightly domed top to the liquid to visualize surface tension
            const domeGeometry = new THREE.SphereGeometry(0.18, 16, 16, 0, Math.PI * 2, 0, Math.PI * 0.2);
            const dome = new THREE.Mesh(domeGeometry, liquidMaterial);
            dome.position.y = 0.1;
            dome.rotation.x = Math.PI;
            beakerGroup.add(dome);
            
            // Add a visual showing inward and tangential forces with arrows
            // Create a ring of small arrows at the surface
            const arrowGroup = new THREE.Group();
            
            // Create the arrow shape using cone and cylinder
            function createArrow(x, z, rotation) {
                const arrowGroup = new THREE.Group();
                
                // Arrow shaft
                const shaftGeometry = new THREE.CylinderGeometry(0.01, 0.01, 0.1, 8);
                const shaftMaterial = new THREE.MeshStandardMaterial({
                    color: 0xFFFF00,
                    roughness: 0.3,
                    metalness: 0.5,
                    emissive: 0xFFFF00,
                    emissiveIntensity: 0.5
                });
                
                const shaft = new THREE.Mesh(shaftGeometry, shaftMaterial);
                shaft.position.set(0, 0, 0.05);
                shaft.rotation.x = Math.PI / 2;
                arrowGroup.add(shaft);
                
                // Arrow head
                const headGeometry = new THREE.ConeGeometry(0.02, 0.04, 8);
                const head = new THREE.Mesh(headGeometry, shaftMaterial);
                head.position.set(0, 0, 0.12);
                head.rotation.x = Math.PI / 2;
                arrowGroup.add(head);
                
                arrowGroup.position.set(x, 0.1, z);
                arrowGroup.rotation.y = rotation;
                
                return arrowGroup;
            }
            
            // Create arrows around the surface pointing inward
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const x = Math.cos(angle) * 0.18;
                const z = Math.sin(angle) * 0.18;
                const arrow = createArrow(x, z, angle + Math.PI);
                arrowGroup.add(arrow);
            }
            
            beakerGroup.add(arrowGroup);
            
            // Create a small "Why?" label
            const whyLabelGeometry = new THREE.PlaneGeometry(0.3, 0.1);
            const whyLabelMaterial = new THREE.MeshBasicMaterial({
                color: 0xFFFF00, 
                transparent: true,
                opacity: 0.9,
                side: THREE.DoubleSide
            });
            
            const whyLabel = new THREE.Mesh(whyLabelGeometry, whyLabelMaterial);
            whyLabel.position.set(0, 0.4, 0);
            whyLabel.rotation.x = -Math.PI / 6;
            beakerGroup.add(whyLabel);
            
            // Position the beaker
            beakerGroup.position.set(-0.5, 0.95, -2);
            beakerGroup.userData = { 
                isInteractive: true, 
                slideURL: 'slide2.html',
                name: 'Why Surface Tension Happens', 
                description: 'Examine the forces that create surface tension',
                title: 'Why Surface Tension Happens'
            };
            labGroup.add(beakerGroup);
            
            // 3. Droplet model - for Slide 3 about "Why is surface tension important"
            const dropletGroup = new THREE.Group();
            
            // Droplet shape
            const dropletGeometry = new THREE.SphereGeometry(0.2, 32, 32);
            const dropletMaterial = new THREE.MeshStandardMaterial({
                color: 0x4FC3F7,
                transparent: true,
                opacity: 0.7,
                roughness: 0.1,
                metalness: 0.2
            });
            
            const droplet = new THREE.Mesh(dropletGeometry, dropletMaterial);
            dropletGroup.add(droplet);
            
            // Stand for the droplet model
            const standGeometry = new THREE.CylinderGeometry(0.05, 0.1, 0.3, 16);
            const standMaterial = new THREE.MeshStandardMaterial({
                color: 0x9E9E9E,
                roughness: 0.5,
                metalness: 0.5
            });
            
            const stand = new THREE.Mesh(standGeometry, standMaterial);
            stand.position.y = -0.25;
            dropletGroup.add(stand);
            
            // Base of stand
            const standBaseGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.05, 16);
            const standBase = new THREE.Mesh(standBaseGeometry, standMaterial);
            standBase.position.y = -0.4;
            dropletGroup.add(standBase);
            
            // Add a miniature water strider on top of the droplet
            const striderGroup = new THREE.Group();
            
            // Strider body
            const bodyGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.06, 8);
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: 0x333333,
                roughness: 0.7,
                metalness: 0.2
            });
            
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.rotation.x = Math.PI / 2;
            striderGroup.add(body);
            
            // Strider legs
            const legGeometry = new THREE.CylinderGeometry(0.005, 0.005, 0.15, 8);
            const legMaterial = new THREE.MeshStandardMaterial({
                color: 0x333333,
                roughness: 0.7,
                metalness: 0.2
            });
            
            // Create 6 legs
            const legPositions = [
                { x: 0.04, y: 0, z: 0.02, ry: Math.PI / 4 },
                { x: 0.04, y: 0, z: -0.02, ry: Math.PI / 6 },
                { x: 0, y: 0, z: 0.03, ry: Math.PI / 2 },
                { x: 0, y: 0, z: -0.03, ry: Math.PI / 2 },
                { x: -0.04, y: 0, z: 0.02, ry: -Math.PI / 4 },
                { x: -0.04, y: 0, z: -0.02, ry: -Math.PI / 6 }
            ];
            
            legPositions.forEach(pos => {
                const leg = new THREE.Mesh(legGeometry, legMaterial);
                leg.position.set(pos.x, pos.y, pos.z);
                leg.rotation.z = Math.PI / 2;
                leg.rotation.y = pos.ry;
                striderGroup.add(leg);
            });
            
            // Position the strider on top of the droplet
            striderGroup.position.set(0, 0.2, 0);
            striderGroup.scale.set(0.5, 0.5, 0.5);
            dropletGroup.add(striderGroup);
            
            // Add a tiny plant growing up from beneath
            const plantGroup = new THREE.Group();
            
            // Plant stem
            const stemGeometry = new THREE.CylinderGeometry(0.01, 0.01, 0.4, 8);
            const stemMaterial = new THREE.MeshStandardMaterial({
                color: 0x4CAF50,
                roughness: 0.8,
                metalness: 0.1
            });
            
            const stem = new THREE.Mesh(stemGeometry, stemMaterial);
            stem.position.set(0.1, -0.2, 0.1);
            plantGroup.add(stem);
            
            // Plant leaves
            const leafGeometry = new THREE.SphereGeometry(0.03, 8, 8);
            const leafMaterial = new THREE.MeshStandardMaterial({
                color: 0x8BC34A,
                roughness: 0.8,
                metalness: 0.1
            });
            
            const leaf1 = new THREE.Mesh(leafGeometry, leafMaterial);
            leaf1.position.set(0.12, -0.1, 0.12);
            leaf1.scale.set(1, 0.5, 1);
            plantGroup.add(leaf1);
            
            const leaf2 = new THREE.Mesh(leafGeometry, leafMaterial);
            leaf2.position.set(0.08, -0.05, 0.08);
            leaf2.scale.set(1, 0.5, 1);
            plantGroup.add(leaf2);
            
            dropletGroup.add(plantGroup);
            
            // Add "Importance" label
            const importanceLabelGeometry = new THREE.PlaneGeometry(0.3, 0.1);
            const importanceLabelMaterial = new THREE.MeshBasicMaterial({
                color: 0x4CAF50,
                transparent: true,
                opacity: 0.9,
                side: THREE.DoubleSide
            });
            
            const importanceLabel = new THREE.Mesh(importanceLabelGeometry, importanceLabelMaterial);
            importanceLabel.position.set(0, 0.4, 0);
            importanceLabel.rotation.x = -Math.PI / 6;
            dropletGroup.add(importanceLabel);
            
            // Position the droplet model
            dropletGroup.position.set(0.5, 1.1, -2);
            dropletGroup.userData = { 
                isInteractive: true, 
                slideURL: 'slide3.html',
                name: 'Why Surface Tension is Important', 
                description: 'Learn how surface tension enables water striders to walk on water and plants to draw water',
                title: 'Why Surface Tension is Important'
            };
            labGroup.add(dropletGroup);
            
            // 4. Surface tension demonstration apparatus - for Slide 4 about surface tension applications
            const tensionGroup = new THREE.Group();
            
            // Base platform
            const platformGeometry = new THREE.BoxGeometry(0.6, 0.05, 0.4);
            const platformMaterial = new THREE.MeshStandardMaterial({
                color: 0x795548,
                roughness: 0.7,
                metalness: 0.2
            });
            const platform = new THREE.Mesh(platformGeometry, platformMaterial);
            tensionGroup.add(platform);
            
            // Water container - shallow dish
            const dishGeometry = new THREE.CylinderGeometry(0.25, 0.25, 0.05, 32, 1, false);
            const dishMaterial = new THREE.MeshStandardMaterial({
                color: 0xE0E0E0,
                roughness: 0.3,
                metalness: 0.7
            });
            
            const dish = new THREE.Mesh(dishGeometry, dishMaterial);
            dish.position.set(0, 0.05, 0);
            tensionGroup.add(dish);
            
            // Water in dish with slightly raised center to show meniscus
            const waterGeometry = new THREE.CylinderGeometry(0.24, 0.24, 0.02, 32);
            const waterMaterial = new THREE.MeshStandardMaterial({
                color: 0x81D4FA,
                transparent: true,
                opacity: 0.8,
                roughness: 0.1,
                metalness: 0
            });
            
            const water = new THREE.Mesh(waterGeometry, waterMaterial);
            water.position.set(0, 0.035, 0);
            tensionGroup.add(water);
            
            // Create a slight dome on the water surface to show surface tension
            const waterSurfaceGeometry = new THREE.SphereGeometry(0.24, 32, 16, 0, Math.PI * 2, 0, Math.PI * 0.08);
            const waterSurface = new THREE.Mesh(waterSurfaceGeometry, waterMaterial);
            waterSurface.position.set(0, 0.045, 0);
            waterSurface.rotation.x = Math.PI;
            tensionGroup.add(waterSurface);
            
            // Small object on water (like a paper clip)
            const clipGeometry = new THREE.BoxGeometry(0.1, 0.01, 0.02);
            const clipMaterial = new THREE.MeshStandardMaterial({
                color: 0xBDBDBD,
                roughness: 0.3,
                metalness: 0.9
            });
            
            const clip = new THREE.Mesh(clipGeometry, clipMaterial);
            clip.position.set(0, 0.055, 0);
            tensionGroup.add(clip);
            
            // Add a demonstration setup: a needle floating on water
            const needleGeometry = new THREE.CylinderGeometry(0.005, 0.005, 0.12, 8);
            const needleMaterial = new THREE.MeshStandardMaterial({
                color: 0x9E9E9E, // Silver color
                roughness: 0.3,
                metalness: 0.9
            });
            
            const needle = new THREE.Mesh(needleGeometry, needleMaterial);
            needle.rotation.z = Math.PI / 2;
            needle.position.set(-0.1, 0.055, 0.05);
            tensionGroup.add(needle);
            
            // Add a bug (water strider) walking on water
            const bugGroup = new THREE.Group();
            
            // Bug body
            const bugBodyGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.06, 8);
            const bugBodyMaterial = new THREE.MeshStandardMaterial({
                color: 0x795548, // Brown
                roughness: 0.8,
                metalness: 0.2
            });
            
            const bugBody = new THREE.Mesh(bugBodyGeometry, bugBodyMaterial);
            bugBody.rotation.z = Math.PI / 2;
            bugGroup.add(bugBody);
            
            // Bug legs
            const bugLegGeometry = new THREE.CylinderGeometry(0.003, 0.003, 0.08, 4);
            const bugLegMaterial = bugBodyMaterial;
            
            // Create 6 legs
            for (let i = 0; i < 6; i++) {
                const leg = new THREE.Mesh(bugLegGeometry, bugLegMaterial);
                const angle = (Math.PI / 3) * i;
                leg.rotation.x = Math.PI / 2;
                leg.rotation.z = angle;
                leg.position.set(
                    Math.cos(angle) * 0.03,
                    0,
                    Math.sin(angle) * 0.03
                );
                bugGroup.add(leg);
            }
            
            // Position the bug on the water
            bugGroup.position.set(0.1, 0.055, 0.08);
            bugGroup.rotation.x = Math.PI / 2;
            tensionGroup.add(bugGroup);
            
            // Add a small amount of indent under heavy objects to show the effect
            const indentGeometry = new THREE.SphereGeometry(0.05, 16, 16, 0, Math.PI * 2, 0, Math.PI * 0.2);
            const indentMaterial = new THREE.MeshStandardMaterial({
                color: 0x81D4FA,
                transparent: true,
                opacity: 0.6,
                roughness: 0.1,
                metalness: 0
            });
            
            const indent = new THREE.Mesh(indentGeometry, indentMaterial);
            indent.position.set(-0.1, 0.045, 0.05);
            indent.rotation.x = Math.PI;
            tensionGroup.add(indent);
            
            // Add "Applications" label
            const applicationsLabelGeometry = new THREE.PlaneGeometry(0.3, 0.1);
            const applicationsLabelMaterial = new THREE.MeshBasicMaterial({
                color: 0x2196F3,
                transparent: true,
                opacity: 0.9,
                side: THREE.DoubleSide
            });
            
            const applicationsLabel = new THREE.Mesh(applicationsLabelGeometry, applicationsLabelMaterial);
            applicationsLabel.position.set(0, 0.4, 0);
            applicationsLabel.rotation.x = -Math.PI / 6;
            tensionGroup.add(applicationsLabel);
            
            // Position the surface tension apparatus
            tensionGroup.position.set(1.5, 0.85, -2.5);
            tensionGroup.userData = { 
                isInteractive: true, 
                slideURL: 'slide4.html',
                name: 'Surface Tension Applications', 
                description: 'Observe demonstrations and practical applications of water surface tension',
                title: 'Surface Tension Applications'
            };
            labGroup.add(tensionGroup);
            
            // Add a shelf with additional lab equipment on the back wall
            const shelfGeometry = new THREE.BoxGeometry(4, 0.1, 0.5);
            const shelfMaterial = new THREE.MeshStandardMaterial({
                color: 0x8D6E63,
                roughness: 0.8,
                metalness: 0.1
            });
            
            const shelf = new THREE.Mesh(shelfGeometry, shelfMaterial);
            shelf.position.set(0, 2.5, -4.7);
            shelf.castShadow = true;
            shelf.receiveShadow = true;
            labGroup.add(shelf);
            
            // Add some books and decorative items to the shelf
            // Books
            const bookColors = [0xD32F2F, 0x1976D2, 0x388E3C, 0x7B1FA2];
            for (let i = 0; i < 4; i++) {
                const bookGeometry = new THREE.BoxGeometry(0.3, 0.4, 0.2);
                const bookMaterial = new THREE.MeshStandardMaterial({
                    color: bookColors[i],
                    roughness: 0.7,
                    metalness: 0.1
                });
                
                const book = new THREE.Mesh(bookGeometry, bookMaterial);
                book.position.set(-1.5 + i * 0.35, 2.75, -4.55);
                book.castShadow = true;
                labGroup.add(book);
            }
            
            // Add some flasks and other decorative lab equipment
            // Create a flask
            const flaskGroup = new THREE.Group();
            
            // Flask base
            const flaskBottomGeometry = new THREE.SphereGeometry(0.15, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2);
            const flaskMaterial = new THREE.MeshStandardMaterial({
                color: 0xE0F7FA,
                transparent: true,
                opacity: 0.7,
                roughness: 0.1,
                metalness: 0.3
            });
            
            const flaskBottom = new THREE.Mesh(flaskBottomGeometry, flaskMaterial);
            flaskBottom.rotation.x = Math.PI;
            flaskGroup.add(flaskBottom);
            
            // Flask neck
            const flaskNeckGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.2, 16);
            const flaskNeck = new THREE.Mesh(flaskNeckGeometry, flaskMaterial);
            flaskNeck.position.y = 0.1;
            flaskGroup.add(flaskNeck);
            
            // Flask liquid
            const flaskLiquidGeometry = new THREE.SphereGeometry(0.13, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2);
            const flaskLiquidMaterial = new THREE.MeshStandardMaterial({
                color: 0x76FF03,  // Bright green
                transparent: true,
                opacity: 0.8,
                roughness: 0.1,
                metalness: 0.1
            });
            
            const flaskLiquid = new THREE.Mesh(flaskLiquidGeometry, flaskLiquidMaterial);
            flaskLiquid.rotation.x = Math.PI;
            flaskLiquid.position.y = -0.01;
            flaskGroup.add(flaskLiquid);
            
            // Position the flask on the shelf
            flaskGroup.position.set(0.8, 2.7, -4.5);
            labGroup.add(flaskGroup);
            
            // Add a second flask with different colored liquid
            const flask2Group = flaskGroup.clone();
            // Change the liquid color
            flask2Group.children[2].material = new THREE.MeshStandardMaterial({
                color: 0xFF4081,  // Pink
                transparent: true,
                opacity: 0.8,
                roughness: 0.1,
                metalness: 0.1
            });
            flask2Group.position.set(1.2, 2.7, -4.5);
            labGroup.add(flask2Group);
            
            // Add a bunsen burner
            const burnerGroup = new THREE.Group();
            
            // Base
            const burnerBaseGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.05, 16);
            const burnerMaterial = new THREE.MeshStandardMaterial({
                color: 0x424242,
                roughness: 0.5,
                metalness: 0.7
            });
            
            const burnerBase = new THREE.Mesh(burnerBaseGeometry, burnerMaterial);
            burnerGroup.add(burnerBase);
            
            // Tube
            const burnerTubeGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.25, 16);
            const burnerTube = new THREE.Mesh(burnerTubeGeometry, burnerMaterial);
            burnerTube.position.y = 0.15;
            burnerGroup.add(burnerTube);
            
            // Position the burner on the shelf
            burnerGroup.position.set(1.6, 2.675, -4.5);
            labGroup.add(burnerGroup);
            
            // Add a small desk with a computer/notebook in the corner
            const deskGeometry = new THREE.BoxGeometry(2, 0.1, 1);
            const desk = new THREE.Mesh(deskGeometry, tableMaterial);
            desk.position.set(-3.5, 0.8, -4);
            desk.castShadow = true;
            desk.receiveShadow = true;
            labGroup.add(desk);
            
            // Add desk legs
            const deskLegPositions = [
                { x: -4.4, z: -4.4 },
                { x: -2.6, z: -4.4 },
                { x: -4.4, z: -3.6 },
                { x: -2.6, z: -3.6 }
            ];
            
            deskLegPositions.forEach(pos => {
                const deskLeg = new THREE.Mesh(tablelegGeometry, tablelegMaterial);
                deskLeg.position.set(pos.x, 0.4, pos.z);
                deskLeg.castShadow = true;
                labGroup.add(deskLeg);
            });
            
            // Add a notebook/research journal
            const notebookGeometry = new THREE.BoxGeometry(0.5, 0.05, 0.4);
            const notebookMaterial = new THREE.MeshStandardMaterial({
                color: 0x3949AB,
                roughness: 0.8,
                metalness: 0.1
            });
            
            const notebook = new THREE.Mesh(notebookGeometry, notebookMaterial);
            notebook.position.set(-3.5, 0.875, -4);
            notebook.rotation.y = Math.PI / 6;
            notebook.castShadow = true;
            labGroup.add(notebook);
            
            // Add a chair
            const chairGroup = new THREE.Group();
            
            // Chair seat
            const chairSeatGeometry = new THREE.BoxGeometry(0.5, 0.05, 0.5);
            const chairMaterial = new THREE.MeshStandardMaterial({
                color: 0x8D6E63,
                roughness: 0.8,
                metalness: 0.1
            });
            
            const chairSeat = new THREE.Mesh(chairSeatGeometry, chairMaterial);
            chairSeat.position.y = 0.5;
            chairGroup.add(chairSeat);
            
            // Chair legs
            const chairLegGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.5, 8);
            
            const chairLegPositions = [
                { x: 0.2, y: 0.25, z: 0.2 },
                { x: -0.2, y: 0.25, z: 0.2 },
                { x: 0.2, y: 0.25, z: -0.2 },
                { x: -0.2, y: 0.25, z: -0.2 }
            ];
            
            chairLegPositions.forEach(pos => {
                const chairLeg = new THREE.Mesh(chairLegGeometry, chairMaterial);
                chairLeg.position.set(pos.x, pos.y, pos.z);
                chairGroup.add(chairLeg);
            });
            
            // Chair back
            const backPostGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.5, 8);
            
            const backLeftPost = new THREE.Mesh(backPostGeometry, chairMaterial);
            backLeftPost.position.set(-0.2, 0.75, -0.2);
            chairGroup.add(backLeftPost);
            
            const backRightPost = new THREE.Mesh(backPostGeometry, chairMaterial);
            backRightPost.position.set(0.2, 0.75, -0.2);
            chairGroup.add(backRightPost);
            
            // Back rest
            const backRestGeometry = new THREE.BoxGeometry(0.5, 0.3, 0.05);
            const backRest = new THREE.Mesh(backRestGeometry, chairMaterial);
            backRest.position.set(0, 0.85, -0.2);
            chairGroup.add(backRest);
            
            // Position the chair
            chairGroup.position.set(-3, 0, -3.5);
            chairGroup.rotation.y = Math.PI / 6;
            labGroup.add(chairGroup);
            
            // Add a small chalkboard on the wall with water molecules drawn
            const chalkboardGeometry = new THREE.BoxGeometry(2, 1.5, 0.05);
            const chalkboardMaterial = new THREE.MeshStandardMaterial({
                color: 0x212121,
                roughness: 0.9,
                metalness: 0.1
            });
            
            const chalkboard = new THREE.Mesh(chalkboardGeometry, chalkboardMaterial);
            chalkboard.position.set(0, 2.5, -4.89);
            labGroup.add(chalkboard);
            
            // Chalkboard frame
            const frameGeometry = new THREE.BoxGeometry(2.1, 1.6, 0.03);
            const frameMaterial = new THREE.MeshStandardMaterial({
                color: 0x5D4037,
                roughness: 0.8,
                metalness: 0.1
            });
            
            const frame = new THREE.Mesh(frameGeometry, frameMaterial);
            frame.position.set(0, 2.5, -4.92);
            labGroup.add(frame);
            
            // Add the lab equipment group to the scene
            scene.add(labGroup);
            
            return { labGroup, interactiveObjects: [microscopeGroup, beakerGroup, dropletGroup, tensionGroup] };
        }
    // Initialize the scene
    const room = createRoom();
    const { interactiveObjects } = createLabEquipment();
    
    // Initialize camera position
    camera.position.set(0, 1.6, 3); // Start at the door looking in
    camera.lookAt(0, 1.6, 0);
    
    // Event listeners for controls
    document.addEventListener('mousedown', onMouseDown);
    document.addEventListener('mouseup', onMouseUp);
    document.addEventListener('mousemove', onMouseMove);
    document.addEventListener('click', onClick);
    window.addEventListener('resize', onWindowResize);
    document.addEventListener('keydown', onKeyDown);
    document.addEventListener('keyup', onKeyUp);
    
    // Mouse controls
    function onMouseDown(event) {
        isMouseDown = true;
        mouseX = event.clientX;
        mouseY = event.clientY;
    }
    
    function onMouseUp() {
        isMouseDown = false;
    }
    
    function onMouseMove(event) {
        // Update for raycasting
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        
        // Look controls when mouse is down
        if (isMouseDown) {
            const deltaX = event.clientX - mouseX;
            const deltaY = event.clientY - mouseY;
            
            mouseX = event.clientX;
            mouseY = event.clientY;
            
            targetRotationY -= deltaX * 0.01;
            targetRotationX -= deltaY * 0.01;
            
            // Limit vertical rotation
            targetRotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, targetRotationX));
        }
        
        // Check for hover over interactive objects
        checkInteractiveObjectsHover(event);
    }
    
    function onClick() {
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(interactiveObjects, true);
        
        if (intersects.length > 0) {
            // Find the top-level parent with userData
            let currentObject = intersects[0].object;
            while (currentObject && !currentObject.userData.isInteractive) {
                currentObject = currentObject.parent;
            }
            
            if (currentObject && currentObject.userData.isInteractive) {
                showDialog(currentObject.userData.slideURL, currentObject.userData.title);
            }
        }
    }
    
    function checkInteractiveObjectsHover(event) {
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(interactiveObjects, true);
        
        if (intersects.length > 0) {
            // Find the top-level parent with userData
            let currentObject = intersects[0].object;
            let foundInteractive = false;
            
            while (currentObject && !foundInteractive) {
                if (currentObject.userData.isInteractive) {
                    foundInteractive = true;
                    document.body.style.cursor = 'pointer';
                    
                    // Show tooltip
                    tooltip.textContent = currentObject.userData.name + ': ' + currentObject.userData.description;
                    tooltip.style.left = (event.clientX + 10) + 'px';
                    tooltip.style.top = (event.clientY + 10) + 'px';
                    tooltip.style.opacity = '1';
                    break;
                }
                currentObject = currentObject.parent;
            }
            
            if (!foundInteractive) {
                document.body.style.cursor = 'default';
                tooltip.style.opacity = '0';
            }
        } else {
            document.body.style.cursor = 'default';
            tooltip.style.opacity = '0';
        }
    }
    
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    function onKeyDown(event) {
        const key = event.key.toLowerCase();
        if (keys.hasOwnProperty(key)) {
            keys[key] = true;
        }
    }
    
    function onKeyUp(event) {
        const key = event.key.toLowerCase();
        if (keys.hasOwnProperty(key)) {
            keys[key] = false;
        }
    }
    
    // Animation loop
    function animate() {
        requestAnimationFrame(animate);
        
        // Smooth rotation
        currentRotationX += (targetRotationX - currentRotationX) * 0.1;
        currentRotationY += (targetRotationY - currentRotationY) * 0.1;
        
        // Apply rotation to camera direction
        const direction = new THREE.Vector3();
        direction.x = Math.sin(currentRotationY) * Math.cos(currentRotationX);
        direction.y = Math.sin(currentRotationX);
        direction.z = Math.cos(currentRotationY) * Math.cos(currentRotationX);
        direction.normalize();
        
        // Determine forward and right vectors for WASD movement
        const forward = new THREE.Vector3(direction.x, 0, direction.z).normalize();
        const right = new THREE.Vector3();
        right.crossVectors(forward, new THREE.Vector3(0, 1, 0)).normalize();
        
        // Apply movement
        if (keys.w) camera.position.addScaledVector(forward, moveSpeed);
        if (keys.s) camera.position.addScaledVector(forward, -moveSpeed);
        if (keys.a) camera.position.addScaledVector(right, -moveSpeed);
        if (keys.d) camera.position.addScaledVector(right, moveSpeed);
        
        // Limit movement within the hut
        const roomSize = 4.8;
        camera.position.x = Math.max(-roomSize, Math.min(roomSize, camera.position.x));
        camera.position.z = Math.max(-roomSize, Math.min(roomSize, camera.position.z));
        camera.position.y = 1.6; // Keep at eye level
        
        // Set camera direction based on rotation
        camera.lookAt(camera.position.clone().add(direction));
        
        renderer.render(scene, camera);
    }
    
    // Start the animation loop
    animate();
            </script>
            </body>
        </html>